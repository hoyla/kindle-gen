package com.gu.kpp.nitf

import java.nio.file.Path

import better.files._
import org.scalatest.ParallelTestExecution

/** A helper for testing against the files generated by the older script.
  * You need to download the older files in order for this to work.
  */
class HistoricalNitfTransformationSpec extends XhtmlToNitfTransformationSpec with ParallelTestExecution {
  override protected def printTransformedResult = false

  // uncomment the following to enable the test
  override def filesToTest = Nil // HistoricalNitfTransformationSpec.historicalNitfFiles
}

object HistoricalNitfTransformationSpec {
  val historicalNitfFiles: TraversableOnce[Path] = {
    println(s"[note] ${getClass.getSimpleName}: Collecting files to test against...")

    val basePath = File("../kindle-publications-extracted/feeds")
    val invalidXmlFiles = Set(
      // empty content / wrong XML
      "20180117.0111.moved/122_theguardianweather_weather_world.nitf",
      "20180118.0111.moved/115_theguardianweather_weather_world.nitf",
      "20180119.0111.moved/133_theguardianweather_weather_world.nitf",
      "20180120.0111.moved/125_theguardianweather_weather_world.nitf",
      "20180121.0111.moved/201_theguardianweather_weather_world.nitf",
      "20180122.0111.moved/170_theobserverweather_weather_obs.nitf",
      "20180123.0111.moved/107_theguardianweather_weather_world.nitf",
      "20180124.0111.moved/112_theguardianweather_weather_world.nitf",
      "20180125.0111.moved/115_theguardianweather_weather_world.nitf",
      // misplaced </figure> without an opening tag
      "20171029.0111.moved/086_mysterious-object-detected-speeding-past-the-sun-could-be-from-another-solar-system-a2017-u1.nitf",
      "20171213.0111.moved/038_astronomers-to-check-interstellar-body-for-signs-of-alien-technology.nitf"
    ).map(basePath / _)

    basePath.walk()
      .filter(_.toString.endsWith(".nitf"))
      .filter { file =>
        val s = file.path.getName(3).toString.stripSuffix(".0111.moved")
        (1 to 31).map("201806%02d".format(_)).contains(s)
      }
      .filterNot(invalidXmlFiles)
      .map(_.path)
      .toSeq
      .sorted(implicitly[Ordering[Path]].reverse)
  }
}
